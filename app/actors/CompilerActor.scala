package actors

import actors.LevelGenerationActor.GetGridMap
import actors.StatsActor.{ StatsDoneUpdating, UpdateStats }
import actors.messages._
import akka.actor.{ Actor, ActorRef, Props }
import akka.pattern.ask
import akka.util.Timeout
import compiler.processor.{ Frame, Processor }
import compiler.{ Compiler, GridAndProgram }
import controllers.MathBotCompiler
import javax.inject.Inject
import loggers.MathBotLogger
import model.PlayerTokenModel
import model.models.GridMap
import play.api.libs.concurrent.Execution.Implicits.defaultContext
import play.modules.reactivemongo.ReactiveMongoApi

import scala.concurrent.duration._

class CompilerActor @Inject()(out: ActorRef, tokenId: String)(
    val reactiveMongoApi: ReactiveMongoApi,
    statsActor: ActorRef,
    levelActor: ActorRef,
    logger: MathBotLogger
) extends Actor
    with PlayerTokenModel {

  import MathBotCompiler._

  case class ProgramState(stream: Stream[Frame],
                          iterator: Iterator[Frame],
                          grid: GridMap,
                          program: GridAndProgram,
                          clientFrames: List[ClientFrame] = List.empty[ClientFrame],
                          previousSteps: Int = 0,
                          leftoverFrame : Option[Frame] = None,
                          exitOnSuccess : Boolean = false
                         )

  implicit val timeout: Timeout = 5000.minutes

  var currentCompiler: Option[ProgramState] = None

  private val className = "CompilerActor"

  def createFrames(leadingFrames : List[Frame]) ={
    val clientFrames = leadingFrames
      .map(f => ClientFrame(f))

    // Tag the cells that haven't changed compared to the previous frame.
    val taggedDuplicates = clientFrames
      .map(c => (c.robotState.grid, Set.empty[ClientCell]))
      .scanLeft((Option(ClientGrid(cells = Set.empty[ClientCell])), Set.empty[ClientCell])) { (previous, current) =>
        val changes = for {
          p <- previous._1
          c <- current._1
        } yield {
          val prevDiff = p.cells diff c.cells
          val currDiff = c.cells diff p.cells
          val modifiedPart1 = (prevDiff ++ currDiff)
            .groupBy(c => c.location)
            .filter(g => g._2.size > 1)
          val modifiedPart2 =
            c.cells.filter(p => modifiedPart1.contains(p.location))
          val removed = (prevDiff diff currDiff).filter(p => !modifiedPart1.contains(p.location))
          val newCells = (currDiff diff prevDiff).filter(p => !modifiedPart1.contains(p.location))
          removed.map(c => c.copy(items = List.empty[String])) ++ modifiedPart2 ++ newCells
        }
        (current._1, changes.getOrElse(Set.empty[ClientCell]))
      }
    // Remove the tagged grid cells to compress the amount of json sent through the websocket
    taggedDuplicates.tail
      .zip(clientFrames)
      .map(
        v =>
          v._2.copy(
            robotState = v._2.robotState
              .copy(grid = Some(ClientGrid(cells = v._1._2)))
          )
      )
  }

  def checkForSuccess(programState: ProgramState, frame : Frame) : Boolean = programState.grid.success(frame, programState.program.problem)

  def createLastFrame(programState : ProgramState, frame : Frame)= {
    // Check to see if the last frame generated by the processor matches the problem check
    if (checkForSuccess(programState, frame))
    {
      List(MathBotCompiler.ClientFrame.success(frame))
    } else {
      List(MathBotCompiler.ClientFrame.failure(frame))
    }
  }

  def sendFrames(programState : ProgramState, clientFrames : List[ClientFrame]) = {
    out ! CompilerOutput(clientFrames, programState.grid.problem)
    if (clientFrames.last.isSuccess()) {
      statsActor ! UpdateStats(success = true, tokenId)
      currentCompiler = None
    }
    if (clientFrames.last.isFailure()) {
      currentCompiler = None
    }
  }


  override def receive: Receive = {
    case CompilerExecute(steps, problem, exitOnSuccess) =>
      // This approach to detecting a new program is deprecated. The client should now flag
      // new programs in the request json
      currentCompiler match {
        case Some(_) => self ! CompilerContinue(steps)
        case None => self ! CompilerCreate(steps, problem, exitOnSuccess)
      }

    case CompilerCreate(steps, problem, exitOnSuccess) =>
      logger.LogInfo(className, "Creating new compiler.")

      for {
        tokenList <- getToken(tokenId)
        grid <- (levelActor ? GetGridMap(tokenList)).mapTo[GridMap]
      } yield {
        for {
          token <- tokenList
          main = token.lambdas.head.main
          funcs = token.lambdas.head.activeFuncs
          commands = token.lambdas.head.cmds
          program <- Compiler.compile(main, funcs, commands, grid, problem)
        } yield {
          val processor = Processor(program)
          val stream = processor.execute()
          currentCompiler = Some(
            ProgramState(stream = stream, iterator = stream.iterator, program = program, grid = grid, exitOnSuccess = exitOnSuccess)
          )
          self ! CompilerContinue(steps)
        }
      }

    case CompilerContinue(steps) =>
      logger.LogInfo(className, s"Stepping compiler for $steps steps")
      for {
        programState <- currentCompiler
      } yield {
        // filter out non-robot frames (eg function calls and program start)
        val robotFrames = programState.iterator.filter(f => f.robotLocation.isDefined).take(steps).toList

        val executeSomeFrames = (if (programState.exitOnSuccess) {
          if (programState.leftoverFrame.exists(lf => checkForSuccess(programState, lf))) {
            Seq.empty[Frame] // When the leftover is the success frame, don't return addtional frames
          } else {
            // Generate a temporary index for the program frames and search for a success frame.
            // Truncate the frames to the first successfult frame
            val frames = robotFrames.zipWithIndex
            frames.find(frame => checkForSuccess(programState, frame._1)).map(successFrame => frames.take(successFrame._2 + 1)).getOrElse(frames).map(f => f._1)
          }
        } else {
          robotFrames
        }).toList

        // if the compiler generated less frames than requested we assume the program completed
        val programCompleted = executeSomeFrames.length < steps

        // This logic is done this way for now because the client has to query to get group of frames and will hang
        // if a query never responds with a frame. Eventually this gets replaced with an async stream of frames coming
        // from the compiler that will be controlled with back pressure message coming from the client.
        (currentCompiler.flatMap(_.leftoverFrame), executeSomeFrames) match {
          case (None, List(frame)) =>
            // When the compiler generates a single frame, assume its the last frame.
            sendFrames(programState, createLastFrame(programState, frame))
          case (None, leadingFrames :+ last) if !programCompleted =>
            // More than one frame, send the leading frames and save the last frame for the next request
            sendFrames(programState, createFrames(leadingFrames))
            currentCompiler = currentCompiler.map(_.copy(leftoverFrame = Some(last)))
          case (None, leadingFrames :+ last) if programCompleted =>
            // When short the requested frames, assume the program has finished and compute the last frame too
            sendFrames(programState, createFrames(leadingFrames) ++ createLastFrame(programState, last))
          case (Some(leftover), leadingFrames :+ last) if !programCompleted =>
            // With a leftover, and last, this is executing somewhere in the middle of the program.
            sendFrames(programState, createFrames(leftover +: leadingFrames))
            currentCompiler = currentCompiler.map(_.copy(leftoverFrame = Some(last)))
          case (Some(leftover), leadingFrames :+ last) if programCompleted =>
            // With the program completed, we send all the remaining frames
            sendFrames(programState, createFrames(leftover +: leadingFrames) ++ createLastFrame(programState, last))
          case (Some(leftover), Nil) =>
            // The compiler generates no more frames, so the leftover is now the last.
            sendFrames(programState, createLastFrame(programState, leftover))
          case (Some(leftover), List(last)) =>
            // The compiler generated one more frame, and there was one leftover, send both frames
            sendFrames(programState, createFrames(List(leftover)) ++ createLastFrame(programState, last))
          case (None, Nil) =>
          // This case does nothing, should never happen
        }
      }

    case _: CompilerHalt =>
      logger.LogInfo(className, "Compiler halted")
      currentCompiler = None
      out ! CompilerHalted()

    case Left(_: StatsDoneUpdating) =>
      logger.LogInfo(className, s"Stats updated successfully. token_id:$tokenId")

    case Right(invalidJson: ActorFailed) =>
      logger.LogFailure(className, invalidJson.msg)
      self ! invalidJson.msg

    case _ => out ! ActorFailed("Unknown command submitted to compiler")
  }
}

object CompilerActor {
  def props(out: ActorRef,
            tokenId: String,
            reactiveMongoApi: ReactiveMongoApi,
            statsActor: ActorRef,
            levelActor: ActorRef,
            logger: MathBotLogger) =
    Props(new CompilerActor(out, tokenId)(reactiveMongoApi, statsActor, levelActor, logger))
}
